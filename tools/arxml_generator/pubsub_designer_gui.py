#!/usr/bin/env python3
"""
Pub/Sub Service Designer GUI for Adaptive AUTOSAR.

A user-friendly GUI for designing SOME/IP Pub/Sub services from scratch,
with auto-generated IDs, live YAML/ARXML/C++ preview, and one-click
generation of all build artifacts.

Usage:
    python3 tools/arxml_generator/pubsub_designer_gui.py

Requirements:
    pip install pyyaml
"""

from __future__ import annotations

import hashlib
import sys
import textwrap
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional, Any, Dict

import tkinter as tk
from tkinter import filedialog, messagebox, ttk

# Assume generate_arxml.py / generate_ara_com_binding.py are in the same directory
_SCRIPT_DIR = Path(__file__).parent
sys.path.insert(0, str(_SCRIPT_DIR))

try:
    import yaml
except ImportError:
    yaml = None  # type: ignore

try:
    from generate_arxml import build_arxml_tree, serialize_tree, GenerationContext
    _HAS_GENERATE_ARXML = True
except ImportError:
    _HAS_GENERATE_ARXML = False

try:
    from generate_ara_com_binding import extract_someip_binding, generate_header_text
    import xml.etree.ElementTree as ET
    _HAS_BINDING_GEN = True
except ImportError:
    _HAS_BINDING_GEN = False

# ---------------------------------------------------------------------------
# Data classes
# ---------------------------------------------------------------------------

@dataclass
class EventConfig:
    """Configuration for a single SOME/IP event."""
    name: str = "StatusEvent"
    event_id: int = 0x8001
    event_group_id: int = 1
    payload_type: str = "MyPayload"
    payload_fields: str = "std::uint32_t sequence;\nstd::uint16_t value;"


@dataclass
class ServiceConfig:
    """Complete service configuration."""
    service_name: str = "MyService"
    package_name: str = "MyServiceManifest"
    service_id: int = 0x1234
    instance_id: int = 1
    major_version: int = 1
    minor_version: int = 0
    # Network settings
    provider_ip: str = "127.0.0.1"
    provider_port: int = 30509
    consumer_ip: str = "127.0.0.1"
    consumer_port: int = 30510
    multicast_ip: str = "239.255.0.1"
    multicast_port: int = 30509
    # Service Discovery timing
    sd_delay_min: int = 20
    sd_delay_max: int = 200
    # Event list
    events: List[EventConfig] = field(default_factory=lambda: [EventConfig()])
    # C++ output settings
    cpp_namespace: str = "my_app::generated"
    # Output directory
    output_dir: str = "/tmp/pubsub_gen"


# ---------------------------------------------------------------------------
# ID generation helpers
# ---------------------------------------------------------------------------

def auto_service_id(name: str) -> int:
    """Generate a deterministic service ID from the service name (range 0x0100–0xFFFE)."""
    raw = int(hashlib.sha256(name.encode()).hexdigest()[:4], 16)
    sid = (raw & 0xFF00) | 0x0001
    return max(0x0100, min(sid, 0xFFFE))


def auto_event_id(base: int = 0x8001, index: int = 0) -> int:
    """Generate a sequential event ID."""
    return base + index


# ---------------------------------------------------------------------------
# YAML generation
# ---------------------------------------------------------------------------

def generate_yaml_text(cfg: ServiceConfig) -> str:
    """Generate YAML text from a ServiceConfig."""
    lines = [
        f"# Pub/Sub Service: {cfg.service_name}",
        f"# Auto-generated by pubsub_designer_gui.py",
        "",
        "variables:",
        f'  PROVIDER_IP: "{cfg.provider_ip}"',
        f'  CONSUMER_IP: "{cfg.consumer_ip}"',
        f'  MULTICAST_IP: "{cfg.multicast_ip}"',
        "",
        "autosar:",
        '  schema_namespace: "http://autosar.org/schema/r4.0"',
        '  schema_location: "http://autosar.org/schema/r4.0 autosar_00050.xsd"',
        "  packages:",
        f"    - short_name: {cfg.package_name}",
        "",
        "      # Network layer: Ethernet cluster",
        "      communication_cluster:",
        f"        short_name: {cfg.service_name}Cluster",
        "        protocol_version: 1",
        "        ethernet_physical_channels:",
        f"          - short_name: {cfg.service_name}Channel",
        "            network_endpoints:",
        f"              - short_name: ProviderEndpoint",
        '                ipv4_address: "${PROVIDER_IP}"',
        f"              - short_name: ConsumerEndpoint",
        '                ipv4_address: "${CONSUMER_IP}"',
        "",
        "      # Transport layer: UDP port bindings",
        "      ethernet_communication_connectors:",
        f"        - short_name: {cfg.service_name}ProviderConnector",
        "          ap_application_endpoints:",
        f"            - short_name: ProviderUdpEndpoint",
        "              transport: udp",
        f"              port: {cfg.provider_port}",
        "",
        f"        - short_name: {cfg.service_name}ConsumerConnector",
        "          ap_application_endpoints:",
        f"            - short_name: ConsumerUdpEndpoint",
        "              transport: udp",
        f"              port: {cfg.consumer_port}",
        "",
        "      # SOME/IP service instance definitions",
        "      someip:",
        "",
        "        # Provider (Publisher) side",
        "        provided_service_instances:",
        f"          - short_name: {cfg.service_name}ProviderInstance",
        "            service_interface:",
        f"              id: {hex(cfg.service_id)}",
        f"              major: {cfg.major_version}",
        f"              minor: {cfg.minor_version}",
        f"            service_instance_id: {cfg.instance_id}",
        "            event_groups:",
    ]

    for ev in cfg.events:
        lines += [
            f"              - short_name: {ev.name}Group",
            f"                event_group_id: {ev.event_group_id}",
            f"                event_id: {hex(ev.event_id)}",
            f"                multicast_udp_port: {cfg.multicast_port}",
            '                ipv4_multicast_ip_address: "${MULTICAST_IP}"',
        ]

    lines += [
        "            sd_server:",
        f"              initial_delay_min: {cfg.sd_delay_min}",
        f"              initial_delay_max: {cfg.sd_delay_max}",
        "",
        "        # Consumer (Subscriber) side",
        "        required_service_instances:",
        f"          - short_name: {cfg.service_name}ConsumerRequirement",
        f"            service_interface_id: {hex(cfg.service_id)}",
        f"            major_version: {cfg.major_version}",
        f"            minor_version: {cfg.minor_version}",
        "            required_event_groups:",
    ]

    for ev in cfg.events:
        lines += [
            f"              - short_name: {ev.name}GroupRequirement",
            f"                event_group_id: {ev.event_group_id}",
            f"                event_id: {hex(ev.event_id)}",
        ]

    lines += [
        "            sd_client:",
        f"              initial_delay_min: {cfg.sd_delay_min}",
        f"              initial_delay_max: {cfg.sd_delay_max}",
        "",
    ]

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# ARXML generation
# ---------------------------------------------------------------------------

def generate_arxml_text(cfg: ServiceConfig) -> str:
    """Generate ARXML text from a ServiceConfig using generate_arxml.py API."""
    if not _HAS_GENERATE_ARXML:
        return "# generate_arxml.py not found. Place it in the same directory."

    event_groups_provided = []
    event_groups_required = []
    for ev in cfg.events:
        event_groups_provided.append({
            "short_name": f"{ev.name}Group",
            "event_group_id": ev.event_group_id,
            "event_id": ev.event_id,
            "multicast_udp_port": cfg.multicast_port,
            "ipv4_multicast_ip_address": cfg.multicast_ip,
        })
        event_groups_required.append({
            "short_name": f"{ev.name}GroupRequirement",
            "event_group_id": ev.event_group_id,
            "event_id": ev.event_id,
        })

    merged_config: Dict[str, Any] = {
        "autosar": {
            "schema_namespace": "http://autosar.org/schema/r4.0",
            "schema_location": "http://autosar.org/schema/r4.0 autosar_00050.xsd",
            "packages": [
                {
                    "short_name": cfg.package_name,
                    "communication_cluster": {
                        "short_name": f"{cfg.service_name}Cluster",
                        "protocol_version": 1,
                        "ethernet_physical_channels": [
                            {
                                "short_name": f"{cfg.service_name}Channel",
                                "network_endpoints": [
                                    {"short_name": "ProviderEndpoint", "ipv4_address": cfg.provider_ip},
                                    {"short_name": "ConsumerEndpoint", "ipv4_address": cfg.consumer_ip},
                                ],
                            }
                        ],
                    },
                    "ethernet_communication_connectors": [
                        {
                            "short_name": f"{cfg.service_name}ProviderConnector",
                            "ap_application_endpoints": [
                                {"short_name": "ProviderUdpEndpoint", "transport": "udp", "port": cfg.provider_port}
                            ],
                        },
                        {
                            "short_name": f"{cfg.service_name}ConsumerConnector",
                            "ap_application_endpoints": [
                                {"short_name": "ConsumerUdpEndpoint", "transport": "udp", "port": cfg.consumer_port}
                            ],
                        },
                    ],
                    "someip": {
                        "provided_service_instances": [
                            {
                                "short_name": f"{cfg.service_name}ProviderInstance",
                                "service_interface": {
                                    "id": cfg.service_id,
                                    "major": cfg.major_version,
                                    "minor": cfg.minor_version,
                                },
                                "service_instance_id": cfg.instance_id,
                                "event_groups": event_groups_provided,
                                "sd_server": {
                                    "initial_delay_min": cfg.sd_delay_min,
                                    "initial_delay_max": cfg.sd_delay_max,
                                },
                            }
                        ],
                        "required_service_instances": [
                            {
                                "short_name": f"{cfg.service_name}ConsumerRequirement",
                                "service_interface_id": cfg.service_id,
                                "major_version": cfg.major_version,
                                "minor_version": cfg.minor_version,
                                "required_event_groups": event_groups_required,
                                "sd_client": {
                                    "initial_delay_min": cfg.sd_delay_min,
                                    "initial_delay_max": cfg.sd_delay_max,
                                },
                            }
                        ],
                    },
                }
            ],
        }
    }

    try:
        gen_ctx = GenerationContext(strict=False, allow_extensions=False)
        root = build_arxml_tree(merged_config, gen_ctx)
        return serialize_tree(root, indent=4)
    except Exception as exc:  # noqa: BLE001
        return f"# ARXML generation error: {exc}"


# ---------------------------------------------------------------------------
# C++ code generation
# ---------------------------------------------------------------------------

def generate_binding_header_text(cfg: ServiceConfig, arxml_text: str) -> str:
    """Generate C++ binding constants header from ARXML text."""
    if not _HAS_BINDING_GEN:
        return "// generate_ara_com_binding.py not found."

    try:
        import xml.etree.ElementTree as ET_inner
        root = ET_inner.fromstring(arxml_text)
        first_event = cfg.events[0] if cfg.events else EventConfig()
        binding = extract_someip_binding(
            root,
            f"{cfg.service_name}ProviderInstance",
            f"{first_event.name}Group",
        )
        output_path = Path(cfg.output_dir) / f"{cfg.service_name.lower()}_binding.h"
        return generate_header_text(
            binding=binding,
            output_path=output_path,
            namespace_value=cfg.cpp_namespace,
        )
    except Exception as exc:  # noqa: BLE001
        return f"// Binding header generation error: {exc}"


def generate_types_h_text(cfg: ServiceConfig) -> str:
    """Generate types.h containing Skeleton and Proxy class definitions."""
    sname = cfg.service_name

    skeleton_events = []
    proxy_events = []
    event_constants = []
    event_bindings_sk = []
    event_bindings_px = []
    skeleton_binding_helpers = []
    proxy_binding_helpers = []

    for ev in cfg.events:
        skeleton_events.append(f"ara::com::SkeletonEvent<{ev.payload_type}> {ev.name};")
        proxy_events.append(f"ara::com::ProxyEvent<{ev.payload_type}> {ev.name};")
        event_constants.append(
            f"constexpr std::uint16_t k{ev.name}Id{{0x{ev.event_id:04X}U}};"
        )
        event_constants.append(
            f"constexpr std::uint16_t k{ev.name}GroupId{{0x{ev.event_group_id:04X}U}};"
        )
        skeleton_binding_helpers.append(
            f"""\
    static std::unique_ptr<ara::com::internal::SkeletonEventBinding>
    Create{ev.name}Binding()
    {{
        auto binding = ara::com::internal::BindingFactory::CreateSkeletonEventBinding(
            ara::com::internal::TransportBinding::kVsomeip,
            ara::com::internal::EventBindingConfig{{
                kServiceId,
                kInstanceId,
                k{ev.name}Id,
                k{ev.name}GroupId,
                kMajorVersion}});
        if (!binding)
        {{
            throw std::runtime_error("Failed to create SOME/IP skeleton event binding.");
        }}
        return binding;
    }}"""
        )
        event_bindings_sk.append(
            f"              {ev.name}{{Create{ev.name}Binding()}}"
        )
        proxy_binding_helpers.append(
            f"""\
    static std::unique_ptr<ara::com::internal::ProxyEventBinding>
    Create{ev.name}Binding(const HandleType &handle)
    {{
        auto binding = ara::com::internal::BindingFactory::CreateProxyEventBinding(
            ara::com::internal::TransportBinding::kVsomeip,
            ara::com::internal::EventBindingConfig{{
                handle.GetServiceId(),
                handle.GetInstanceId(),
                k{ev.name}Id,
                k{ev.name}GroupId,
                kMajorVersion}});
        if (!binding)
        {{
            throw std::runtime_error("Failed to create SOME/IP proxy event binding.");
        }}
        return binding;
    }}"""
        )
        event_bindings_px.append(
            f"              {ev.name}{{Create{ev.name}Binding(handle)}}"
        )

    # Generate payload structs
    struct_defs = []
    seen_types: set = set()
    for ev in cfg.events:
        if ev.payload_type not in seen_types:
            seen_types.add(ev.payload_type)
            fields_indented = textwrap.indent(ev.payload_fields, "    ")
            struct_defs.append(
                f"struct {ev.payload_type}\n"
                f"{{\n"
                f"{fields_indented}\n"
                f"}};"
            )

    structs_str = "\n\n".join(struct_defs)
    sk_events_str = "\n        ".join(skeleton_events)
    px_events_str = "\n        ".join(proxy_events)
    constants_str = "\n".join(event_constants)
    sk_init_str = ",\n".join(event_bindings_sk)
    px_init_str = ",\n".join(event_bindings_px)
    sk_helpers_str = "\n\n".join(skeleton_binding_helpers)
    px_helpers_str = "\n\n".join(proxy_binding_helpers)

    guard = f"USER_APPS_{sname.upper()}_TYPES_H"
    ns_parts = cfg.cpp_namespace.split("::")
    ns_open = "\n".join(f"namespace {p} {{" for p in ns_parts)
    ns_close = "\n".join("}" for _ in ns_parts)

    return f"""\
#ifndef {guard}
#define {guard}

// Auto-generated by pubsub_designer_gui.py. Customize as needed.
// Service: {sname}  ServiceID=0x{cfg.service_id:04X}  InstanceID=0x{cfg.instance_id:04X}

#include <cstdint>
#include <memory>
#include <stdexcept>

#include <ara/com/event.h>
#include <ara/com/internal/binding_factory.h>
#include <ara/com/service_handle_type.h>
#include <ara/com/service_proxy_base.h>
#include <ara/com/service_skeleton_base.h>
#include <ara/com/types.h>
#include <ara/core/instance_specifier.h>
#include <ara/core/result.h>

{ns_open}

// ─────────────────────────────────────────────────────────────
//  Service identifier constants (derived from ARXML)
// ─────────────────────────────────────────────────────────────
constexpr std::uint16_t kServiceId{{0x{cfg.service_id:04X}U}};
constexpr std::uint16_t kInstanceId{{0x{cfg.instance_id:04X}U}};
constexpr std::uint8_t  kMajorVersion{{0x{cfg.major_version:02X}U}};
constexpr std::uint8_t  kMinorVersion{{0x{cfg.minor_version:02X}U}};
{constants_str}

// ─────────────────────────────────────────────────────────────
//  Payload structs (customize fields for your application)
// ─────────────────────────────────────────────────────────────
{structs_str}

// ─────────────────────────────────────────────────────────────
//  InstanceSpecifier helper
// ─────────────────────────────────────────────────────────────
inline ara::core::InstanceSpecifier CreateInstanceSpecifierOrThrow(const char* path)
{{
    auto result = ara::core::InstanceSpecifier::Create(path);
    if (!result.HasValue())
        throw std::runtime_error(result.Error().Message());
    return result.Value();
}}

// ─────────────────────────────────────────────────────────────
//  Skeleton (Publisher / Provider)
// ─────────────────────────────────────────────────────────────
class {sname}Skeleton : public ara::com::ServiceSkeletonBase
{{
private:
    // In commercial AUTOSAR stacks this section is generated and vendor-specific.
{sk_helpers_str}

public:
    {sk_events_str}

    explicit {sname}Skeleton(ara::core::InstanceSpecifier specifier)
        : ara::com::ServiceSkeletonBase{{
              std::move(specifier),
              kServiceId, kInstanceId, kMajorVersion, kMinorVersion,
              ara::com::MethodCallProcessingMode::kEvent}},
{sk_init_str}
    {{
    }}
}};

// ─────────────────────────────────────────────────────────────
//  Proxy (Subscriber / Consumer)
// ─────────────────────────────────────────────────────────────
class {sname}Proxy : public ara::com::ServiceProxyBase
{{
public:
    using HandleType = ara::com::ServiceHandleType;

private:
    // In commercial AUTOSAR stacks this section is generated and vendor-specific.
{px_helpers_str}

public:

    {px_events_str}

    explicit {sname}Proxy(HandleType handle)
        : ara::com::ServiceProxyBase{{handle}},
{px_init_str}
    {{
    }}

    static ara::core::Result<ara::com::ServiceHandleContainer<HandleType>>
    FindService(ara::core::InstanceSpecifier specifier)
    {{
        (void)specifier;
        return ara::com::ServiceProxyBase::FindService(kServiceId, kInstanceId);
    }}

    static ara::core::Result<ara::com::FindServiceHandle>
    StartFindService(
        ara::com::FindServiceHandler<HandleType> handler,
        ara::core::InstanceSpecifier specifier)
    {{
        (void)specifier;
        return ara::com::ServiceProxyBase::StartFindService(
            std::move(handler), kServiceId, kInstanceId);
    }}

    static void StopFindService(ara::com::FindServiceHandle handle)
    {{
        (void)ara::com::ServiceProxyBase::StopFindService(handle);
    }}
}};

{ns_close}

#endif  // {guard}
"""


def generate_cmake_snippet(cfg: ServiceConfig) -> str:
    """Generate CMake build guide for the service."""
    out_dir = cfg.output_dir
    sname = cfg.service_name.lower()
    arxml_file = f"{out_dir}/{sname}_manifest.arxml"
    yaml_file = f"{out_dir}/{sname}_service.yaml"
    binding_h = f"{out_dir}/{sname}_binding.h"
    provider_cpp = f"{out_dir}/{sname}_provider_app.cpp"
    consumer_cpp = f"{out_dir}/{sname}_consumer_app.cpp"

    return f"""\
# ════════════════════════════════════════════════════════════════
#  Build Guide: {cfg.service_name} Pub/Sub Service
# ════════════════════════════════════════════════════════════════

# ── Step 1: Generate ARXML from YAML ───────────────────────────
python3 tools/arxml_generator/generate_arxml.py \\
  --input  {yaml_file} \\
  --output {arxml_file} \\
  --overwrite \\
  --print-summary

# ── Step 2: Generate C++ binding header from ARXML ─────────────
python3 tools/arxml_generator/generate_ara_com_binding.py \\
  --input   {arxml_file} \\
  --output  {binding_h} \\
  --namespace {cfg.cpp_namespace} \\
  --provided-service-short-name  {cfg.service_name}ProviderInstance \\
  --provided-event-group-short-name {cfg.events[0].name if cfg.events else "EventGroup"}Group

# ── Step 3: Add to user_apps CMakeLists.txt ────────────────────
# In user_apps/src/apps/CMakeLists.txt or a dedicated CMakeLists.txt:

add_user_template_target(
  {sname}_provider
  {provider_cpp}
  AdaptiveAutosarAP::ara_core
  AdaptiveAutosarAP::ara_com
  AdaptiveAutosarAP::ara_log
)
target_include_directories({sname}_provider PRIVATE {out_dir})

add_user_template_target(
  {sname}_consumer
  {consumer_cpp}
  AdaptiveAutosarAP::ara_core
  AdaptiveAutosarAP::ara_com
  AdaptiveAutosarAP::ara_log
)
target_include_directories({sname}_consumer PRIVATE {out_dir})

# ── Step 4: Build ──────────────────────────────────────────────
./scripts/build_user_apps_from_opt.sh --prefix /opt/autosar_ap

# Or via cmake directly:
cmake -S user_apps -B build-user-apps \\
  -DAUTOSAR_AP_INSTALL_PREFIX=/opt/autosar_ap
cmake --build build-user-apps -j$(nproc)

# ── Step 5: Run (two terminals) ────────────────────────────────
export AUTOSAR_AP_PREFIX=/opt/autosar_ap
export VSOMEIP_CONFIGURATION=$AUTOSAR_AP_PREFIX/configuration/vsomeip-pubsub-sample.json
export LD_LIBRARY_PATH=$AUTOSAR_AP_PREFIX/lib:/opt/vsomeip/lib:${{LD_LIBRARY_PATH:-}}

# Terminal 1: Publisher
./build-user-apps/{sname}_provider

# Terminal 2: Subscriber
./build-user-apps/{sname}_consumer
"""


def generate_provider_app_text(cfg: ServiceConfig) -> str:
    """Generate sample publisher application code."""
    sname = cfg.service_name
    ns = cfg.cpp_namespace
    first_ev = cfg.events[0] if cfg.events else EventConfig()
    specifier_path = f"AdaptiveAutosar/UserApps/{sname}Provider"

    return f"""\
// Auto-generated Publisher app for {sname}.
// Include types.h and adjust payload fields as needed.

#include <atomic>
#include <chrono>
#include <csignal>
#include <iostream>
#include <thread>

#include <ara/core/initialization.h>
#include <ara/log/logging_framework.h>

#include "types.h"

namespace
{{
    std::atomic<bool> gRunning{{true}};
    void HandleSignal(int) {{ gRunning.store(false); }}
}}

int main()
{{
    std::signal(SIGINT,  HandleSignal);
    std::signal(SIGTERM, HandleSignal);

    // 1) Initialize ara::core runtime
    if (!ara::core::Initialize().HasValue())
    {{
        std::cerr << "Initialize failed\\n";
        return 1;
    }}

    // 2) Create logger
    auto logging = std::unique_ptr<ara::log::LoggingFramework>{{
        ara::log::LoggingFramework::Create("PUB", ara::log::LogMode::kConsole,
                                           ara::log::LogLevel::kInfo, "{sname} Publisher")}};
    auto& logger = logging->CreateLogger("PUB", "Publisher", ara::log::LogLevel::kInfo);

    // 3) Build Skeleton (service provider)
    using namespace {ns};
    auto specifier = CreateInstanceSpecifierOrThrow("{specifier_path}");
    {sname}Skeleton skeleton{{std::move(specifier)}};

    // 4) Offer the service
    if (!skeleton.OfferService().HasValue())
    {{
        std::cerr << "OfferService failed\\n";
        ara::core::Deinitialize();
        return 1;
    }}

    // 5) Offer the event channel
    skeleton.{first_ev.name}.Offer();

    std::cout << "[{sname}Provider] Publishing started. Press Ctrl+C to stop.\\n";

    // 6) Publish periodic payloads
    std::uint32_t seq = 0;
    while (gRunning.load())
    {{
        ++seq;
        {first_ev.payload_type} payload{{}};
        payload.sequence = seq;
        // TODO: populate other fields with real data

        skeleton.{first_ev.name}.Send(payload);

        if (seq % 10 == 0)
        {{
            auto s = logger.WithLevel(ara::log::LogLevel::kInfo);
            s << "Published seq=" << seq;
            logging->Log(logger, ara::log::LogLevel::kInfo, s);
        }}
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }}

    // 7) Cleanup
    skeleton.{first_ev.name}.StopOffer();
    skeleton.StopOfferService();
    ara::core::Deinitialize();
    return 0;
}}
"""


def generate_consumer_app_text(cfg: ServiceConfig) -> str:
    """Generate sample subscriber application code."""
    sname = cfg.service_name
    ns = cfg.cpp_namespace
    first_ev = cfg.events[0] if cfg.events else EventConfig()
    specifier_path = f"AdaptiveAutosar/UserApps/{sname}Consumer"

    return f"""\
// Auto-generated Subscriber app for {sname}.

#include <atomic>
#include <chrono>
#include <csignal>
#include <iostream>
#include <memory>
#include <mutex>
#include <thread>
#include <vector>

#include <ara/core/initialization.h>
#include <ara/log/logging_framework.h>

#include "types.h"

namespace
{{
    std::atomic<bool> gRunning{{true}};
    void HandleSignal(int) {{ gRunning.store(false); }}
}}

int main()
{{
    std::signal(SIGINT,  HandleSignal);
    std::signal(SIGTERM, HandleSignal);

    if (!ara::core::Initialize().HasValue())
    {{
        std::cerr << "Initialize failed\\n";
        return 1;
    }}

    auto logging = std::unique_ptr<ara::log::LoggingFramework>{{
        ara::log::LoggingFramework::Create("SUB", ara::log::LogMode::kConsole,
                                           ara::log::LogLevel::kInfo, "{sname} Subscriber")}};
    auto& logger = logging->CreateLogger("SUB", "Subscriber", ara::log::LogLevel::kInfo);

    using namespace {ns};

    // 1) Start async service discovery
    std::mutex handleMutex;
    std::vector<{sname}Proxy::HandleType> handles;

    auto specifier = CreateInstanceSpecifierOrThrow("{specifier_path}");
    auto findResult = {sname}Proxy::StartFindService(
        [&handleMutex, &handles]({sname}Proxy::HandleType found)
        {{
            std::lock_guard<std::mutex> lock(handleMutex);
            handles = {{found}};
        }},
        std::move(specifier));

    if (!findResult.HasValue())
    {{
        std::cerr << "StartFindService failed\\n";
        ara::core::Deinitialize();
        return 1;
    }}

    std::cout << "[{sname}Consumer] Waiting for service. Press Ctrl+C to stop.\\n";

    std::unique_ptr<{sname}Proxy> proxy;
    std::uint32_t recvCount = 0;

    while (gRunning.load())
    {{
        // 2) Create proxy and subscribe once a service handle is available
        if (!proxy)
        {{
            std::lock_guard<std::mutex> lock(handleMutex);
            if (!handles.empty())
            {{
                proxy = std::make_unique<{sname}Proxy>(handles.front());

                // 3) Subscribe with a fixed queue depth
                proxy->{first_ev.name}.Subscribe(32U);

                // 4) Register receive handler
                proxy->{first_ev.name}.SetReceiveHandler(
                    [&proxy, &logging, &logger, &recvCount]()
                    {{
                        proxy->{first_ev.name}.GetNewSamples(
                            [&](ara::com::SamplePtr<{first_ev.payload_type}> sample)
                            {{
                                ++recvCount;
                                auto s = logger.WithLevel(ara::log::LogLevel::kInfo);
                                s << "Received #" << recvCount
                                  << " seq=" << sample->sequence;
                                logging->Log(logger, ara::log::LogLevel::kInfo, s);
                            }}, 16U);
                    }});
            }}
        }}
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }}

    // 5) Cleanup
    if (proxy)
    {{
        proxy->{first_ev.name}.UnsetReceiveHandler();
        proxy->{first_ev.name}.Unsubscribe();
    }}
    {sname}Proxy::StopFindService(findResult.Value());
    ara::core::Deinitialize();
    return 0;
}}
"""


# ---------------------------------------------------------------------------
# Event edit dialog
# ---------------------------------------------------------------------------

class EventEditDialog(tk.Toplevel):
    """Modal dialog for adding or editing an event."""

    def __init__(self, parent: tk.Widget, ev: Optional[EventConfig] = None) -> None:
        super().__init__(parent)
        self.title("Event Configuration")
        self.resizable(False, False)
        self.grab_set()

        self.result: Optional[EventConfig] = None
        ev = ev or EventConfig()

        self._name_var = tk.StringVar(value=ev.name)
        self._event_id_var = tk.StringVar(value=hex(ev.event_id))
        self._group_id_var = tk.IntVar(value=ev.event_group_id)
        self._payload_var = tk.StringVar(value=ev.payload_type)
        self._fields_text: Optional[tk.Text] = None
        self._fields_init = ev.payload_fields

        self._build()

    def _build(self) -> None:
        pad = {"padx": 8, "pady": 4}
        f = ttk.Frame(self, padding=12)
        f.pack(fill=tk.BOTH, expand=True)

        rows = [
            ("Event name:", self._name_var),
            ("Event ID (hex):", self._event_id_var),
            ("Payload type name:", self._payload_var),
        ]
        for r, (lbl, var) in enumerate(rows):
            ttk.Label(f, text=lbl).grid(row=r, column=0, sticky=tk.W, **pad)
            ttk.Entry(f, textvariable=var, width=30).grid(row=r, column=1, sticky=tk.EW, **pad)

        ttk.Label(f, text="Event group ID:").grid(row=len(rows), column=0, sticky=tk.W, **pad)
        ttk.Spinbox(f, from_=1, to=255, textvariable=self._group_id_var, width=8).grid(
            row=len(rows), column=1, sticky=tk.W, **pad)

        ttk.Label(f, text="Payload fields (C++):").grid(
            row=len(rows)+1, column=0, columnspan=2, sticky=tk.W, **pad)
        self._fields_text = tk.Text(f, width=44, height=5, font=("Courier New", 9))
        self._fields_text.insert("1.0", self._fields_init)
        self._fields_text.grid(row=len(rows)+2, column=0, columnspan=2, sticky=tk.EW, **pad)

        btn_frame = ttk.Frame(f)
        btn_frame.grid(row=len(rows)+3, column=0, columnspan=2, pady=8)
        ttk.Button(btn_frame, text="OK", command=self._ok, width=10).pack(side=tk.LEFT, padx=4)
        ttk.Button(btn_frame, text="Cancel", command=self.destroy, width=10).pack(side=tk.LEFT, padx=4)

        f.columnconfigure(1, weight=1)

    def _ok(self) -> None:
        try:
            event_id = int(self._event_id_var.get(), 16)
        except ValueError:
            messagebox.showerror("Error", "Event ID must be a hex value (e.g. 0x8001).", parent=self)
            return

        fields_text = self._fields_text.get("1.0", tk.END).strip() if self._fields_text else ""
        self.result = EventConfig(
            name=self._name_var.get().strip(),
            event_id=event_id,
            event_group_id=self._group_id_var.get(),
            payload_type=self._payload_var.get().strip(),
            payload_fields=fields_text,
        )
        self.destroy()


# ---------------------------------------------------------------------------
# Code preview widget
# ---------------------------------------------------------------------------

class CodePreview(ttk.Frame):
    """Scrollable text preview with copy and save buttons."""

    def __init__(self, parent: tk.Widget, label: str = "") -> None:
        super().__init__(parent)
        if label:
            ttk.Label(self, text=label, font=("TkDefaultFont", 9, "bold")).pack(anchor=tk.W, pady=(0, 2))

        btn_row = ttk.Frame(self)
        btn_row.pack(fill=tk.X)
        ttk.Button(btn_row, text="Copy to clipboard", command=self._copy).pack(side=tk.LEFT)
        ttk.Button(btn_row, text="Save to file", command=self._save).pack(side=tk.LEFT, padx=4)

        frame = ttk.Frame(self)
        frame.pack(fill=tk.BOTH, expand=True)
        self._text = tk.Text(frame, wrap=tk.NONE, font=("Courier New", 9),
                             state=tk.DISABLED, bg="#1e1e1e", fg="#d4d4d4",
                             insertbackground="white")
        self._text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        sb_y = ttk.Scrollbar(frame, command=self._text.yview)
        sb_y.pack(side=tk.RIGHT, fill=tk.Y)
        sb_x = ttk.Scrollbar(self, orient=tk.HORIZONTAL, command=self._text.xview)
        sb_x.pack(fill=tk.X)
        self._text.configure(yscrollcommand=sb_y.set, xscrollcommand=sb_x.set)

    def set_text(self, text: str) -> None:
        self._text.configure(state=tk.NORMAL)
        self._text.delete("1.0", tk.END)
        self._text.insert("1.0", text)
        self._text.configure(state=tk.DISABLED)

    def get_text(self) -> str:
        return self._text.get("1.0", tk.END)

    def _copy(self) -> None:
        self.clipboard_clear()
        self.clipboard_append(self.get_text())

    def _save(self) -> None:
        path = filedialog.asksaveasfilename(
            filetypes=[("All files", "*.*"), ("YAML", "*.yaml"), ("ARXML", "*.arxml"),
                       ("C++ header", "*.h"), ("C++ source", "*.cpp")])
        if path:
            Path(path).write_text(self.get_text(), encoding="utf-8")
            messagebox.showinfo("Saved", f"File saved:\n{path}")


# ---------------------------------------------------------------------------
# Main application window
# ---------------------------------------------------------------------------

class PubSubDesignerGui(tk.Tk):
    """Main window of the Pub/Sub Service Designer."""

    def __init__(self) -> None:
        super().__init__()
        self.title("Adaptive AUTOSAR — Pub/Sub Service Designer")
        self.geometry("1100x760")
        self.minsize(900, 600)

        self._cfg = ServiceConfig()
        self._events: List[EventConfig] = [EventConfig()]

        self._build_ui()
        self._refresh_event_list()
        self._refresh_previews()

    # ───────────────────────────────────────────────────────────
    #  UI construction
    # ───────────────────────────────────────────────────────────

    def _build_ui(self) -> None:
        top = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
        top.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)

        design_frame = ttk.LabelFrame(top, text="Service Design", padding=8)
        top.add(design_frame, weight=1)

        preview_nb = ttk.Notebook(top)
        top.add(preview_nb, weight=2)

        self._build_design_panel(design_frame)
        self._build_preview_tabs(preview_nb)

        bottom = ttk.Frame(self)
        bottom.pack(fill=tk.X, padx=6, pady=(0, 6))

        self._status_var = tk.StringVar(value="Ready")
        ttk.Label(bottom, textvariable=self._status_var, anchor=tk.W).pack(side=tk.LEFT, fill=tk.X, expand=True)

        ttk.Button(bottom, text="Refresh Preview", command=self._refresh_previews).pack(side=tk.RIGHT, padx=4)
        ttk.Button(bottom, text="Generate All & Save", command=self._generate_all).pack(side=tk.RIGHT, padx=4)

    def _build_design_panel(self, parent: ttk.LabelFrame) -> None:
        nb = ttk.Notebook(parent)
        nb.pack(fill=tk.BOTH, expand=True)

        f1 = ttk.Frame(nb, padding=8)
        nb.add(f1, text="Basic")
        self._build_basic_tab(f1)

        f2 = ttk.Frame(nb, padding=8)
        nb.add(f2, text="Network")
        self._build_network_tab(f2)

        f3 = ttk.Frame(nb, padding=8)
        nb.add(f3, text="Events")
        self._build_event_tab(f3)

        f4 = ttk.Frame(nb, padding=8)
        nb.add(f4, text="Output")
        self._build_output_tab(f4)

    def _build_basic_tab(self, f: ttk.Frame) -> None:
        p = {"padx": 4, "pady": 3, "sticky": tk.W}

        ttk.Label(f, text="Service name:").grid(row=0, column=0, **p)
        self._svc_name_var = tk.StringVar(value=self._cfg.service_name)
        ttk.Entry(f, textvariable=self._svc_name_var, width=22).grid(row=0, column=1, sticky=tk.EW, padx=4, pady=3)
        ttk.Button(f, text="Auto-generate ID", command=self._auto_generate_id).grid(row=0, column=2, padx=4)

        ttk.Label(f, text="Package name:").grid(row=1, column=0, **p)
        self._pkg_name_var = tk.StringVar(value=self._cfg.package_name)
        ttk.Entry(f, textvariable=self._pkg_name_var, width=22).grid(row=1, column=1, sticky=tk.EW, padx=4, pady=3)

        ttk.Label(f, text="Service ID (hex):").grid(row=2, column=0, **p)
        self._svc_id_var = tk.StringVar(value=hex(self._cfg.service_id))
        ttk.Entry(f, textvariable=self._svc_id_var, width=12).grid(row=2, column=1, sticky=tk.W, padx=4, pady=3)

        ttk.Label(f, text="Instance ID:").grid(row=3, column=0, **p)
        self._inst_id_var = tk.IntVar(value=self._cfg.instance_id)
        ttk.Spinbox(f, from_=1, to=65535, textvariable=self._inst_id_var, width=8).grid(
            row=3, column=1, sticky=tk.W, padx=4, pady=3)

        ttk.Label(f, text="Version:").grid(row=4, column=0, **p)
        ver_frame = ttk.Frame(f)
        ver_frame.grid(row=4, column=1, sticky=tk.W, padx=4, pady=3)
        self._major_var = tk.IntVar(value=self._cfg.major_version)
        self._minor_var = tk.IntVar(value=self._cfg.minor_version)
        ttk.Label(ver_frame, text="Major:").pack(side=tk.LEFT)
        ttk.Spinbox(ver_frame, from_=0, to=255, textvariable=self._major_var, width=5).pack(side=tk.LEFT, padx=2)
        ttk.Label(ver_frame, text="Minor:").pack(side=tk.LEFT, padx=(8, 0))
        ttk.Spinbox(ver_frame, from_=0, to=65535, textvariable=self._minor_var, width=7).pack(side=tk.LEFT, padx=2)

        ttk.Separator(f, orient=tk.HORIZONTAL).grid(row=5, column=0, columnspan=3, sticky=tk.EW, pady=6)
        ttk.Label(f, text="SD initial delay:").grid(row=6, column=0, **p)
        sd_frame = ttk.Frame(f)
        sd_frame.grid(row=6, column=1, sticky=tk.W, padx=4)
        self._sd_min_var = tk.IntVar(value=self._cfg.sd_delay_min)
        self._sd_max_var = tk.IntVar(value=self._cfg.sd_delay_max)
        ttk.Label(sd_frame, text="Min:").pack(side=tk.LEFT)
        ttk.Spinbox(sd_frame, from_=0, to=5000, textvariable=self._sd_min_var, width=6).pack(side=tk.LEFT, padx=2)
        ttk.Label(sd_frame, text="ms  Max:").pack(side=tk.LEFT)
        ttk.Spinbox(sd_frame, from_=0, to=5000, textvariable=self._sd_max_var, width=6).pack(side=tk.LEFT, padx=2)
        ttk.Label(sd_frame, text="ms").pack(side=tk.LEFT)

        ttk.Label(f, text="C++ namespace:").grid(row=7, column=0, **p)
        self._ns_var = tk.StringVar(value=self._cfg.cpp_namespace)
        ttk.Entry(f, textvariable=self._ns_var, width=30).grid(row=7, column=1, sticky=tk.EW, padx=4, pady=3)

        f.columnconfigure(1, weight=1)

    def _build_network_tab(self, f: ttk.Frame) -> None:
        p = {"padx": 4, "pady": 3, "sticky": tk.W}
        info = [
            ("Provider IP:", "provider_ip", self._cfg.provider_ip),
            ("Provider port:", "provider_port", self._cfg.provider_port),
            ("Consumer IP:", "consumer_ip", self._cfg.consumer_ip),
            ("Consumer port:", "consumer_port", self._cfg.consumer_port),
            ("Multicast IP:", "multicast_ip", self._cfg.multicast_ip),
            ("Multicast port:", "multicast_port", self._cfg.multicast_port),
        ]
        self._net_vars: dict = {}
        for r, (label, key, default) in enumerate(info):
            ttk.Label(f, text=label).grid(row=r, column=0, **p)
            var = tk.StringVar(value=str(default))
            ttk.Entry(f, textvariable=var, width=18).grid(row=r, column=1, sticky=tk.W, padx=4, pady=3)
            self._net_vars[key] = var

        ttk.Separator(f, orient=tk.HORIZONTAL).grid(row=len(info), column=0, columnspan=2, sticky=tk.EW, pady=8)
        info_text = (
            "• Loopback test: use 127.0.0.1 for both provider and consumer\n"
            "• Cross-ECU: use the actual IP addresses of each ECU\n"
            "• Multicast: 239.0.0.0/8 range recommended for local networks\n"
            "• Ports: choose unused ports in the range 1024–65535"
        )
        ttk.Label(f, text=info_text, justify=tk.LEFT, foreground="gray").grid(
            row=len(info)+1, column=0, columnspan=2, sticky=tk.W, padx=4)

        f.columnconfigure(1, weight=1)

    def _build_event_tab(self, f: ttk.Frame) -> None:
        cols = ("name", "event_id", "group_id", "payload_type")
        self._event_tree = ttk.Treeview(f, columns=cols, show="headings", height=8)
        for col, head, width in [
            ("name", "Event name", 130),
            ("event_id", "Event ID", 80),
            ("group_id", "Group ID", 75),
            ("payload_type", "Payload type", 120),
        ]:
            self._event_tree.heading(col, text=head)
            self._event_tree.column(col, width=width, minwidth=50)

        self._event_tree.pack(fill=tk.BOTH, expand=True)
        self._event_tree.bind("<Double-1>", lambda _: self._edit_event())

        btn = ttk.Frame(f)
        btn.pack(fill=tk.X, pady=4)
        ttk.Button(btn, text="Add", command=self._add_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn, text="Edit", command=self._edit_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn, text="Remove", command=self._remove_event).pack(side=tk.LEFT, padx=2)

        ttk.Label(f, text="Tip: double-click a row to edit.", foreground="gray").pack(anchor=tk.W)

    def _build_output_tab(self, f: ttk.Frame) -> None:
        p = {"padx": 4, "pady": 4, "sticky": tk.W}
        ttk.Label(f, text="Output directory:").grid(row=0, column=0, **p)
        self._output_dir_var = tk.StringVar(value=self._cfg.output_dir)
        ttk.Entry(f, textvariable=self._output_dir_var, width=30).grid(row=0, column=1, sticky=tk.EW, padx=4, pady=4)
        ttk.Button(f, text="Browse", command=self._browse_output_dir).grid(row=0, column=2, padx=4)

        ttk.Label(f, text="Generated files:", font=("TkDefaultFont", 9, "bold")).grid(
            row=1, column=0, columnspan=3, sticky=tk.W, pady=(8, 2), padx=4)
        files_text = (
            "  • <service>_service.yaml     — YAML definition\n"
            "  • <service>_manifest.arxml   — ARXML manifest\n"
            "  • <service>_binding.h        — C++ binding constants\n"
            "  • types.h                    — Skeleton / Proxy classes\n"
            "  • <service>_provider_app.cpp — Publisher sample code\n"
            "  • <service>_consumer_app.cpp — Subscriber sample code\n"
            "  • BUILD_GUIDE.sh             — Build commands"
        )
        ttk.Label(f, text=files_text, justify=tk.LEFT).grid(
            row=2, column=0, columnspan=3, sticky=tk.W, padx=4)

        f.columnconfigure(1, weight=1)

    def _build_preview_tabs(self, nb: ttk.Notebook) -> None:
        tabs = [
            ("YAML", "_yaml_preview"),
            ("ARXML", "_arxml_preview"),
            ("C++ types.h", "_types_preview"),
            ("C++ binding.h", "_binding_preview"),
            ("Provider App", "_provider_preview"),
            ("Consumer App", "_consumer_preview"),
            ("Build Guide", "_build_preview"),
        ]
        for label, attr_name in tabs:
            frame = ttk.Frame(nb, padding=4)
            nb.add(frame, text=label)
            preview = CodePreview(frame)
            preview.pack(fill=tk.BOTH, expand=True)
            setattr(self, attr_name, preview)

    # ───────────────────────────────────────────────────────────
    #  Event management
    # ───────────────────────────────────────────────────────────

    def _refresh_event_list(self) -> None:
        for item in self._event_tree.get_children():
            self._event_tree.delete(item)
        for ev in self._events:
            self._event_tree.insert("", tk.END, values=(
                ev.name, hex(ev.event_id), ev.event_group_id, ev.payload_type))

    def _add_event(self) -> None:
        next_id = auto_event_id(0x8001, len(self._events))
        next_grp = len(self._events) + 1
        default = EventConfig(
            name=f"Event{len(self._events)+1}",
            event_id=next_id,
            event_group_id=next_grp,
        )
        dlg = EventEditDialog(self, default)
        self.wait_window(dlg)
        if dlg.result:
            self._events.append(dlg.result)
            self._refresh_event_list()

    def _edit_event(self) -> None:
        sel = self._event_tree.selection()
        if not sel:
            return
        idx = self._event_tree.index(sel[0])
        if idx >= len(self._events):
            return
        dlg = EventEditDialog(self, self._events[idx])
        self.wait_window(dlg)
        if dlg.result:
            self._events[idx] = dlg.result
            self._refresh_event_list()

    def _remove_event(self) -> None:
        sel = self._event_tree.selection()
        if not sel:
            return
        idx = self._event_tree.index(sel[0])
        if 0 <= idx < len(self._events):
            del self._events[idx]
            self._refresh_event_list()

    # ───────────────────────────────────────────────────────────
    #  ID auto-generation
    # ───────────────────────────────────────────────────────────

    def _auto_generate_id(self) -> None:
        name = self._svc_name_var.get().strip() or "MyService"
        self._svc_id_var.set(hex(auto_service_id(name)))
        if not self._pkg_name_var.get().strip():
            self._pkg_name_var.set(f"{name}Manifest")
        if not self._ns_var.get().strip():
            self._ns_var.set(f"{name.lower()}::generated")

    # ───────────────────────────────────────────────────────────
    #  Collect config from form
    # ───────────────────────────────────────────────────────────

    def _collect_config(self) -> ServiceConfig:
        try:
            svc_id = int(self._svc_id_var.get(), 16)
        except ValueError:
            svc_id = self._cfg.service_id

        net = self._net_vars
        try:
            prov_port = int(net["provider_port"].get())
            cons_port = int(net["consumer_port"].get())
            mc_port   = int(net["multicast_port"].get())
        except ValueError:
            prov_port, cons_port, mc_port = 30509, 30510, 30509

        return ServiceConfig(
            service_name=self._svc_name_var.get().strip() or "MyService",
            package_name=self._pkg_name_var.get().strip() or "MyServiceManifest",
            service_id=svc_id,
            instance_id=self._inst_id_var.get(),
            major_version=self._major_var.get(),
            minor_version=self._minor_var.get(),
            provider_ip=net["provider_ip"].get(),
            provider_port=prov_port,
            consumer_ip=net["consumer_ip"].get(),
            consumer_port=cons_port,
            multicast_ip=net["multicast_ip"].get(),
            multicast_port=mc_port,
            sd_delay_min=self._sd_min_var.get(),
            sd_delay_max=self._sd_max_var.get(),
            events=list(self._events) if self._events else [EventConfig()],
            cpp_namespace=self._ns_var.get().strip() or "my_app::generated",
            output_dir=self._output_dir_var.get().strip() or "/tmp/pubsub_gen",
        )

    # ───────────────────────────────────────────────────────────
    #  Preview refresh
    # ───────────────────────────────────────────────────────────

    def _refresh_previews(self) -> None:
        self._status_var.set("Generating previews...")
        self.update_idletasks()

        cfg = self._collect_config()
        self._cfg = cfg

        yaml_text = generate_yaml_text(cfg)
        self._yaml_preview.set_text(yaml_text)

        arxml_text = generate_arxml_text(cfg)
        self._arxml_preview.set_text(arxml_text)

        types_text = generate_types_h_text(cfg)
        self._types_preview.set_text(types_text)

        if not arxml_text.startswith("#"):
            binding_text = generate_binding_header_text(cfg, arxml_text)
        else:
            binding_text = "// ARXML generation failed — see ARXML tab."
        self._binding_preview.set_text(binding_text)

        self._provider_preview.set_text(generate_provider_app_text(cfg))
        self._consumer_preview.set_text(generate_consumer_app_text(cfg))
        self._build_preview.set_text(generate_cmake_snippet(cfg))

        self._status_var.set("Preview updated.")

    # ───────────────────────────────────────────────────────────
    #  File generation
    # ───────────────────────────────────────────────────────────

    def _browse_output_dir(self) -> None:
        path = filedialog.askdirectory(title="Select output directory")
        if path:
            self._output_dir_var.set(path)

    def _generate_all(self) -> None:
        self._refresh_previews()
        cfg = self._cfg
        out = Path(cfg.output_dir)
        out.mkdir(parents=True, exist_ok=True)

        sname = cfg.service_name.lower()
        saved = []

        def write(filename: str, content: str) -> None:
            p = out / filename
            p.write_text(content, encoding="utf-8")
            saved.append(str(p))

        write(f"{sname}_service.yaml",        self._yaml_preview.get_text())
        write(f"{sname}_manifest.arxml",       self._arxml_preview.get_text())
        write("types.h",                       self._types_preview.get_text())
        write(f"{sname}_binding.h",            self._binding_preview.get_text())
        write(f"{sname}_provider_app.cpp",     self._provider_preview.get_text())
        write(f"{sname}_consumer_app.cpp",     self._consumer_preview.get_text())
        write("BUILD_GUIDE.sh",                self._build_preview.get_text())

        self._status_var.set(f"Generated {len(saved)} files in: {out}")
        messagebox.showinfo(
            "Generation Complete",
            f"{len(saved)} files written to:\n{out}\n\n" + "\n".join(saved)
        )


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

def main() -> int:
    if yaml is None:
        print("Error: PyYAML is required.\n  pip install pyyaml", file=sys.stderr)
        return 1

    app = PubSubDesignerGui()
    app.mainloop()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
