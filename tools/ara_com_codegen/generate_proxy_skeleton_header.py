#!/usr/bin/env python3
"""Generate Adaptive AUTOSAR proxy/skeleton header from topic mapping.

Input mapping must contain `topic_mappings` entries generated by
`generate_comm_manifest.py`.
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Dict, List


HEADER_PREAMBLE = """#ifndef LWRCL_AUTOSAR_PROXY_SKELETON_HPP_
#define LWRCL_AUTOSAR_PROXY_SKELETON_HPP_

#include <ara/com/event.h>
#include <ara/com/internal/binding_factory.h>
#include <ara/com/sample_ptr.h>
#include <ara/com/service_handle_type.h>
#include <ara/com/service_proxy_base.h>
#include <ara/com/service_skeleton_base.h>
#include <ara/core/instance_specifier.h>
#include <ara/core/result.h>

#include <org/eclipse/cyclonedds/core/cdr/basic_cdr_ser.hpp>

#include <array>
#include <cstddef>
#include <cstdint>
#include <stdexcept>
#include <string>
#include <vector>

namespace lwrcl
{
namespace autosar_generated
{

struct TopicBinding
{
  const char *ros_topic;
  const char *dds_topic;
  const char *instance_specifier;
  std::uint16_t service_interface_id;
  std::uint16_t service_instance_id;
  std::uint16_t event_group_id;
  std::uint16_t event_id;
  std::uint8_t major_version;
  std::uint32_t minor_version;
};

inline ara::core::InstanceSpecifier CreateInstanceSpecifierOrThrow(const char *path)
{
  auto result = ara::core::InstanceSpecifier::Create(path == nullptr ? std::string{} : std::string(path));
  if (result.HasValue())
  {
    return result.Value();
  }

  auto fallback = ara::core::InstanceSpecifier::Create("/ara/com/generated/default");
  if (fallback.HasValue())
  {
    return fallback.Value();
  }

  // InstanceSpecifier should always be creatable for this constant fallback.
  return ara::core::InstanceSpecifier::Create("/ara/com/generated/fallback").Value();
}

template <typename T>
inline std::vector<std::uint8_t> SerializeMessage(const T &message)
{
  using namespace org::eclipse::cyclonedds::core::cdr;

  T mutable_message = message;
  basic_cdr_stream sizer;
  move(sizer, mutable_message, false);
  const std::size_t payload_size = sizer.position();

  std::vector<std::uint8_t> output(payload_size + 4U, 0U);
  output[0] = 0x00;
  output[1] = 0x01;
  output[2] = 0x00;
  output[3] = 0x00;

  basic_cdr_stream writer;
  writer.set_buffer(reinterpret_cast<char *>(output.data() + 4U), payload_size);
  write(writer, mutable_message, false);
  return output;
}

template <typename T>
inline bool DeserializeMessage(const std::vector<std::uint8_t> &payload, T &message)
{
  using namespace org::eclipse::cyclonedds::core::cdr;

  if (payload.size() <= 4U)
  {
    return false;
  }

  basic_cdr_stream reader;
  reader.set_buffer(
      reinterpret_cast<char *>(const_cast<std::uint8_t *>(payload.data() + 4U)),
      payload.size() - 4U);
  read(reader, message, false);
  return true;
}

"""

HEADER_MIDDLE = """
inline const TopicBinding *FindTopicBinding(const std::string &topic_name)
{
  for (std::size_t i = 0; i < kTopicBindings.size(); ++i)
  {
    const auto &entry = kTopicBindings[i];
    if (topic_name == entry.dds_topic || topic_name == entry.ros_topic)
    {
      return &entry;
    }
  }
  return nullptr;
}

inline const TopicBinding &ResolveTopicBindingOrThrow(const std::string &topic_name)
{
  const TopicBinding *binding = FindTopicBinding(topic_name);
  if (binding == nullptr)
  {
    throw std::runtime_error(
        "No generated AUTOSAR topic mapping for: " + topic_name);
  }
  return *binding;
}

class TopicEventSkeleton : public ara::com::ServiceSkeletonBase
{
public:
  ara::com::SkeletonEvent<std::vector<std::uint8_t>> Event;

  explicit TopicEventSkeleton(const std::string &topic_name)
      : TopicEventSkeleton(ResolveTopicBindingOrThrow(topic_name))
  {
  }

  explicit TopicEventSkeleton(const TopicBinding &binding)
      : ara::com::ServiceSkeletonBase(
            CreateInstanceSpecifierOrThrow(binding.instance_specifier),
            binding.service_interface_id,
            binding.service_instance_id,
            binding.major_version,
            binding.minor_version,
            ara::com::MethodCallProcessingMode::kEvent),
        Event(
            ara::com::internal::BindingFactory::CreateSkeletonEventBinding(
                ara::com::internal::TransportBinding::kVsomeip,
                ara::com::internal::EventBindingConfig{
                    binding.service_interface_id,
                    binding.service_instance_id,
                    binding.event_id,
                    binding.event_group_id,
                    binding.major_version})),
        event_group_id_(binding.event_group_id)
  {
  }

  std::uint16_t GetEventGroupId() const
  {
    return event_group_id_;
  }

  ara::core::Result<void> OfferEventService()
  {
    auto offer_service = OfferService();
    if (!offer_service.HasValue())
    {
      return offer_service;
    }
    return Event.Offer();
  }

  void StopEventService()
  {
    Event.StopOffer();
    StopOfferService();
  }

  template <typename SampleType>
  void SendSample(const SampleType &sample)
  {
    Event.Send(SerializeMessage(sample));
  }

private:
  std::uint16_t event_group_id_;
};

class TopicEventProxy : public ara::com::ServiceProxyBase
{
public:
  using HandleType = ara::com::ServiceHandleType;
  ara::com::ProxyEvent<std::vector<std::uint8_t>> Event;

  explicit TopicEventProxy(const std::string &topic_name)
      : TopicEventProxy(ResolveTopicBindingOrThrow(topic_name))
  {
  }

  explicit TopicEventProxy(const TopicBinding &binding)
      : ara::com::ServiceProxyBase(
            HandleType{
                binding.service_interface_id,
                binding.service_instance_id}),
        Event(
            ara::com::internal::BindingFactory::CreateProxyEventBinding(
                ara::com::internal::TransportBinding::kVsomeip,
                ara::com::internal::EventBindingConfig{
                    binding.service_interface_id,
                    binding.service_instance_id,
                    binding.event_id,
                    binding.event_group_id,
                    binding.major_version}))
  {
  }

  template <typename SampleType, typename Handler>
  void TakeSamples(std::size_t max_samples, Handler &&handler)
  {
    (void)Event.GetNewSamples(
        [&handler](ara::com::SamplePtr<std::vector<std::uint8_t>> payload_sample)
        {
          if (!payload_sample)
          {
            return;
          }

          SampleType sample{};
          if (DeserializeMessage(*payload_sample, sample))
          {
            handler(sample);
          }
        },
        max_samples);
  }
};

}  // namespace autosar_generated
}  // namespace lwrcl

#endif  // LWRCL_AUTOSAR_PROXY_SKELETON_HPP_
"""


def parse_u16(value: object) -> int:
    if isinstance(value, int):
        return value & 0xFFFF
    if isinstance(value, str):
        return int(value, 0) & 0xFFFF
    raise ValueError(f"Unsupported numeric value: {value!r}")


def parse_u32(value: object) -> int:
    if isinstance(value, int):
        return value & 0xFFFFFFFF
    if isinstance(value, str):
        return int(value, 0) & 0xFFFFFFFF
    raise ValueError(f"Unsupported numeric value: {value!r}")


def c_quote(text: str) -> str:
    return text.replace("\\", "\\\\").replace('"', '\\"')


def load_mapping(path: Path) -> Dict:
    # Mapping file is emitted as JSON-compatible YAML.
    return json.loads(path.read_text(encoding="utf-8"))


def build_topic_entries(mapping: Dict) -> List[Dict]:
    out: List[Dict] = []
    seen_dds: set[str] = set()

    for entry in mapping.get("topic_mappings", []):
        ara = entry.get("ara", {})
        dds_topic = str(entry.get("dds_topic", "")).strip()
        ros_topic = str(entry.get("ros_topic", "")).strip()
        instance_specifier = str(ara.get("instance_specifier", "")).strip()
        if not dds_topic or not ros_topic:
            continue
        if dds_topic in seen_dds:
            continue
        seen_dds.add(dds_topic)

        out.append(
            {
                "ros_topic": ros_topic,
                "dds_topic": dds_topic,
                "instance_specifier": instance_specifier or "/ara/com/generated/default",
                "service_interface_id": parse_u16(ara.get("service_interface_id", "0x0000")),
                "service_instance_id": parse_u16(ara.get("service_instance_id", "0x0001")),
                "event_group_id": parse_u16(ara.get("event_group_id", "0x0001")),
                "event_id": parse_u16(ara.get("event_id", "0x8001")),
                "major_version": parse_u16(ara.get("major_version", 1)) & 0xFF,
                "minor_version": parse_u32(ara.get("minor_version", 0)),
            }
        )

    out.sort(key=lambda x: x["dds_topic"])
    return out


def generate_header(entries: List[Dict]) -> str:
    lines: List[str] = [HEADER_PREAMBLE]
    lines.append(f"static const std::array<TopicBinding, {len(entries)}> kTopicBindings = {{{{")
    for entry in entries:
        lines.append("    TopicBinding{")
        lines.append(f'        "{c_quote(entry["ros_topic"])}",')
        lines.append(f'        "{c_quote(entry["dds_topic"])}",')
        lines.append(f'        "{c_quote(entry["instance_specifier"])}",')
        lines.append(f'        static_cast<std::uint16_t>(0x{entry["service_interface_id"]:04X}),')
        lines.append(f'        static_cast<std::uint16_t>(0x{entry["service_instance_id"]:04X}),')
        lines.append(f'        static_cast<std::uint16_t>(0x{entry["event_group_id"]:04X}),')
        lines.append(f'        static_cast<std::uint16_t>(0x{entry["event_id"]:04X}),')
        lines.append(f'        static_cast<std::uint8_t>(0x{entry["major_version"]:02X}),')
        lines.append(f'        static_cast<std::uint32_t>(0x{entry["minor_version"]:08X}),')
        lines.append("    },")
    lines.append("}};")
    lines.append(HEADER_MIDDLE)
    return "\n".join(lines)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate Adaptive AUTOSAR proxy/skeleton header."
    )
    parser.add_argument("--mapping", required=True, help="Input topic mapping YAML(JSON-compatible).")
    parser.add_argument("--output", required=True, help="Output header path.")
    parser.add_argument("--print-summary", action="store_true", help="Print summary.")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    mapping_path = Path(args.mapping).resolve()
    output_path = Path(args.output).resolve()

    mapping = load_mapping(mapping_path)
    entries = build_topic_entries(mapping)
    header_text = generate_header(entries)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(header_text, encoding="utf-8")

    if args.print_summary:
        print("[autosar-proxy-skeleton-gen] generation summary")
        print(f"  mapping: {mapping_path}")
        print(f"  output: {output_path}")
        print(f"  topic bindings: {len(entries)}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
