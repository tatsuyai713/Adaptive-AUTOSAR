#!/usr/bin/env python3
"""Generate Adaptive AUTOSAR proxy/skeleton header from topic mapping.

Input mapping must contain `topic_mappings` entries generated by
`generate_comm_manifest.py`.
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Dict, List


HEADER_PREAMBLE = """#ifndef LWRCL_AUTOSAR_PROXY_SKELETON_HPP_
#define LWRCL_AUTOSAR_PROXY_SKELETON_HPP_

#include <ara/com/event_binding_adapter.h>
#include <ara/com/sample_ptr.h>
#include <ara/com/types.h>
#include <ara/core/result.h>

#include <array>
#include <cstddef>
#include <cstdint>
#include <limits>
#include <memory>
#include <stdexcept>
#include <string>
#include <utility>

namespace lwrcl
{
namespace autosar_generated
{

struct TopicBinding
{
  const char *ros_topic;
  const char *dds_topic;
  const char *instance_specifier;
  std::uint16_t service_interface_id;
  std::uint16_t service_instance_id;
  std::uint16_t event_group_id;
  std::uint16_t event_id;
  std::uint8_t major_version;
  std::uint32_t minor_version;
};

"""

HEADER_MIDDLE = """
inline const TopicBinding *FindTopicBinding(const std::string &topic_name)
{
  for (std::size_t i = 0; i < kTopicBindings.size(); ++i)
  {
    const auto &entry = kTopicBindings[i];
    if (topic_name == entry.dds_topic || topic_name == entry.ros_topic)
    {
      return &entry;
    }
  }
  return nullptr;
}

inline const TopicBinding &ResolveTopicBindingOrThrow(const std::string &topic_name)
{
  const TopicBinding *binding = FindTopicBinding(topic_name);
  if (binding == nullptr)
  {
    throw std::runtime_error(
        "No generated AUTOSAR topic mapping for: " + topic_name);
  }
  return *binding;
}

template <typename SampleType>
class TopicEventSkeleton
{
public:
  class EventFacade
  {
  public:
    explicit EventFacade(ara::com::EventPublisherAdapter<SampleType> &adapter)
        : adapter_(adapter)
    {
    }

    ara::core::Result<void> Offer()
    {
      return ara::core::Result<void>::FromValue();
    }

    void StopOffer()
    {
      // No-op: adapter handles lifecycle.
    }

    void Send(const SampleType &sample)
    {
      adapter_.Publish(sample);
    }

  private:
    ara::com::EventPublisherAdapter<SampleType> &adapter_;
  };

  explicit TopicEventSkeleton(const std::string &topic_name)
      : TopicEventSkeleton(ResolveTopicBindingOrThrow(topic_name))
  {
  }

  explicit TopicEventSkeleton(const TopicBinding &binding)
      : adapter_(
            binding.dds_topic == nullptr ? std::string{} : std::string(binding.dds_topic),
            0U),
        Event(adapter_)
  {
  }

  ara::core::Result<void> OfferService()
  {
    return ara::core::Result<void>::FromValue();
  }

  void StopOfferService()
  {
    // No-op: adapter handles lifecycle.
  }

  std::int32_t GetMatchedSubscriptionCount() const
  {
    return adapter_.GetMatchedSubscriptionCount();
  }

  EventFacade Event;

private:
  ara::com::EventPublisherAdapter<SampleType> adapter_;
};

template <typename SampleType>
class TopicEventProxy
{
public:
  class EventFacade
  {
  public:
    explicit EventFacade(ara::com::EventSubscriberAdapter<SampleType> &adapter)
        : adapter_(adapter),
          subscribed_(false)
    {
    }

    void Subscribe(std::size_t)
    {
      subscribed_ = true;
    }

    void Unsubscribe()
    {
      subscribed_ = false;
      adapter_.Stop();
    }

    void UnsetReceiveHandler()
    {
      // No-op: polling mode.
    }

    ara::com::SubscriptionState GetSubscriptionState() const noexcept
    {
      if (!subscribed_)
      {
        return ara::com::SubscriptionState::kNotSubscribed;
      }
      return adapter_.GetMatchedPublicationCount() > 0
                 ? ara::com::SubscriptionState::kSubscribed
                 : ara::com::SubscriptionState::kSubscriptionPending;
    }

    template <typename Handler>
    ara::core::Result<std::size_t> GetNewSamples(
        Handler &&handler,
        std::size_t maxNumberOfSamples = std::numeric_limits<std::size_t>::max())
    {
      std::size_t consumed = 0U;
      const std::uint32_t max_samples_u32 =
          maxNumberOfSamples > std::numeric_limits<std::uint32_t>::max()
              ? std::numeric_limits<std::uint32_t>::max()
              : static_cast<std::uint32_t>(maxNumberOfSamples);

      adapter_.Poll(
          max_samples_u32,
          [&handler, &consumed](const SampleType &sample)
          {
            auto sample_ptr = std::make_unique<const SampleType>(sample);
            handler(ara::com::SamplePtr<SampleType>{std::move(sample_ptr)});
            ++consumed;
          });

      return ara::core::Result<std::size_t>::FromValue(consumed);
    }

  private:
    ara::com::EventSubscriberAdapter<SampleType> &adapter_;
    bool subscribed_;
  };

  explicit TopicEventProxy(const std::string &topic_name)
      : TopicEventProxy(ResolveTopicBindingOrThrow(topic_name))
  {
  }

  explicit TopicEventProxy(const TopicBinding &binding)
      : adapter_(
            binding.dds_topic == nullptr ? std::string{} : std::string(binding.dds_topic),
            0U,
            kDefaultSomeipQueueSize),
        Event(adapter_)
  {
  }

  EventFacade Event;

private:
  static constexpr std::size_t kDefaultSomeipQueueSize = 100U;
  ara::com::EventSubscriberAdapter<SampleType> adapter_;
};

}  // namespace autosar_generated
}  // namespace lwrcl

#endif  // LWRCL_AUTOSAR_PROXY_SKELETON_HPP_
"""


def parse_u16(value: object) -> int:
    if isinstance(value, int):
        return value & 0xFFFF
    if isinstance(value, str):
        return int(value, 0) & 0xFFFF
    raise ValueError(f"Unsupported numeric value: {value!r}")


def parse_u32(value: object) -> int:
    if isinstance(value, int):
        return value & 0xFFFFFFFF
    if isinstance(value, str):
        return int(value, 0) & 0xFFFFFFFF
    raise ValueError(f"Unsupported numeric value: {value!r}")


def c_quote(text: str) -> str:
    return text.replace("\\", "\\\\").replace('"', '\\"')


def load_mapping(path: Path) -> Dict:
    # Mapping file is emitted as JSON-compatible YAML.
    return json.loads(path.read_text(encoding="utf-8"))


def build_topic_entries(mapping: Dict) -> List[Dict]:
    out: List[Dict] = []
    seen_dds: set[str] = set()

    for entry in mapping.get("topic_mappings", []):
        ara = entry.get("ara", {})
        dds_topic = str(entry.get("dds_topic", "")).strip()
        ros_topic = str(entry.get("ros_topic", "")).strip()
        instance_specifier = str(ara.get("instance_specifier", "")).strip()
        if not dds_topic or not ros_topic:
            continue
        if dds_topic in seen_dds:
            continue
        seen_dds.add(dds_topic)

        out.append(
            {
                "ros_topic": ros_topic,
                "dds_topic": dds_topic,
                "instance_specifier": instance_specifier or "/ara/com/generated/default",
                "service_interface_id": parse_u16(ara.get("service_interface_id", "0x0000")),
                "service_instance_id": parse_u16(ara.get("service_instance_id", "0x0001")),
                "event_group_id": parse_u16(ara.get("event_group_id", "0x0001")),
                "event_id": parse_u16(ara.get("event_id", "0x8001")),
                "major_version": parse_u16(ara.get("major_version", 1)) & 0xFF,
                "minor_version": parse_u32(ara.get("minor_version", 0)),
            }
        )

    out.sort(key=lambda x: x["dds_topic"])
    return out


def generate_header(entries: List[Dict]) -> str:
    lines: List[str] = [HEADER_PREAMBLE]
    lines.append(f"static const std::array<TopicBinding, {len(entries)}> kTopicBindings = {{{{")
    for entry in entries:
        lines.append("    TopicBinding{")
        lines.append(f'        "{c_quote(entry["ros_topic"])}",')
        lines.append(f'        "{c_quote(entry["dds_topic"])}",')
        lines.append(f'        "{c_quote(entry["instance_specifier"])}",')
        lines.append(f'        static_cast<std::uint16_t>(0x{entry["service_interface_id"]:04X}),')
        lines.append(f'        static_cast<std::uint16_t>(0x{entry["service_instance_id"]:04X}),')
        lines.append(f'        static_cast<std::uint16_t>(0x{entry["event_group_id"]:04X}),')
        lines.append(f'        static_cast<std::uint16_t>(0x{entry["event_id"]:04X}),')
        lines.append(f'        static_cast<std::uint8_t>(0x{entry["major_version"]:02X}),')
        lines.append(f'        static_cast<std::uint32_t>(0x{entry["minor_version"]:08X}),')
        lines.append("    },")
    lines.append("}};")
    lines.append(HEADER_MIDDLE)
    return "\n".join(lines)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate Adaptive AUTOSAR proxy/skeleton header."
    )
    parser.add_argument("--mapping", required=True, help="Input topic mapping YAML(JSON-compatible).")
    parser.add_argument("--output", required=True, help="Output header path.")
    parser.add_argument("--print-summary", action="store_true", help="Print summary.")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    mapping_path = Path(args.mapping).resolve()
    output_path = Path(args.output).resolve()

    mapping = load_mapping(mapping_path)
    entries = build_topic_entries(mapping)
    header_text = generate_header(entries)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(header_text, encoding="utf-8")

    if args.print_summary:
        print("[autosar-proxy-skeleton-gen] generation summary")
        print(f"  mapping: {mapping_path}")
        print(f"  output: {output_path}")
        print(f"  topic bindings: {len(entries)}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
