# Raspberry Pi ECU Deployment Profile

This profile turns a Raspberry Pi Linux machine into a prototype AUTOSAR-style ECU
using this repository runtime and user apps.

## What This Profile Covers

- Build/install runtime to `/opt/autosar_ap`
- Build `user_apps` against installed runtime only
- Configure SocketCAN on Linux
- Install `systemd` units for:
  - iceoryx RouDi
  - vSomeIP routing manager
  - time synchronization daemon
  - persistency guard daemon
  - IAM policy loader daemon
  - CAN interface manager daemon
  - platform application stack (`adaptive_autosar`, EM/SM/PHM/Diag/Vehicle)
  - execution-manager bridge service (runs user bringup script)
  - user-application monitor daemon (registration/health/watch)
  - watchdog supervisor daemon
  - ECU full-stack app (`CAN + SOME/IP` receive, `DDS` publish)
- Verify transport and ECU paths with a single script

## Prerequisites

- Linux on Raspberry Pi (64-bit recommended)
- C++14 toolchain, CMake, Python3 + PyYAML
- Middleware installed under:
  - `/opt/vsomeip`
  - `/opt/iceoryx`
  - `/opt/cyclonedds`
- `systemd` available

Install prerequisites and middleware:

```bash
sudo ./scripts/install_middleware_stack.sh --install-base-deps
```

## 1) Build and install runtime + user apps

```bash
sudo ./scripts/build_and_install_rpi_ecu_profile.sh \
  --prefix /opt/autosar_ap \
  --runtime-build-dir build-rpi-autosar-ap \
  --user-app-build-dir /opt/autosar_ap/user_apps_build \
  --install-middleware
```

## 2) Configure CAN interface

Physical CAN:

```bash
sudo ./scripts/setup_socketcan_interface.sh --ifname can0 --bitrate 500000
```

Virtual CAN (for bring-up only):

```bash
sudo ./scripts/setup_socketcan_interface.sh --ifname vcan0 --vcan
```

## 3) Install systemd services

```bash
sudo ./scripts/install_rpi_ecu_services.sh \
  --prefix /opt/autosar_ap \
  --user-app-build-dir /opt/autosar_ap/user_apps_build \
  --enable
```

Edit runtime options in:

- `/etc/default/autosar-ecu-full-stack`
- `/etc/default/autosar-vsomeip-routing`
- `/etc/default/autosar-time-sync`
- `/etc/default/autosar-persistency-guard`
- `/etc/default/autosar-iam-policy`
- `/etc/default/autosar-can-manager`
- `/etc/default/autosar-platform-app`
- `/etc/default/autosar-exec-manager`
- `/etc/default/autosar-watchdog`
- `/etc/default/autosar-user-app-monitor`
- `/etc/autosar/iam_policy.csv`

Edit user startup script in:

- `/etc/autosar/bringup.sh`
- `/etc/autosar/startup.sh` (alias)

## 4) Start services

```bash
sudo systemctl start autosar-iox-roudi.service
sudo systemctl start autosar-vsomeip-routing.service
sudo systemctl start autosar-time-sync.service
sudo systemctl start autosar-persistency-guard.service
sudo systemctl start autosar-iam-policy.service
sudo systemctl start autosar-can-manager.service
sudo systemctl start autosar-platform-app.service
sudo systemctl start autosar-exec-manager.service
sudo systemctl start autosar-watchdog.service
sudo systemctl start autosar-user-app-monitor.service
sudo systemctl start autosar-ecu-full-stack.service
sudo systemctl status autosar-vsomeip-routing.service --no-pager
sudo systemctl status autosar-platform-app.service --no-pager
sudo systemctl status autosar-exec-manager.service --no-pager
sudo systemctl status autosar-watchdog.service --no-pager
sudo systemctl status autosar-user-app-monitor.service --no-pager
```

If you use only `bringup.sh` to launch your own apps, disable the fixed sample service:

```bash
sudo systemctl disable --now autosar-ecu-full-stack.service
```

## User bringup workflow

1. Build your application into `${AUTOSAR_USER_APPS_BUILD_DIR}` (default: `/opt/autosar_ap/user_apps_build`).
2. Edit `/etc/autosar/bringup.sh`.
3. Add your launch commands via helper functions (`launch_app` / `launch_app_with_heartbeat` / `launch_app_managed`).
4. Restart execution-manager service:

```bash
sudo systemctl restart autosar-exec-manager.service
```

`autosar-vsomeip-routing.service` keeps SOME/IP routing resident.
`autosar-time-sync.service`, `autosar-persistency-guard.service`, `autosar-iam-policy.service`, and
`autosar-can-manager.service` initialize core resident platform support.
Then `autosar-platform-app.service` starts the built-in platform process stack.
Then `autosar-exec-manager.service` executes your bringup script.
`autosar-user-app-monitor.service` continuously monitors registered app PIDs, optional heartbeat freshness, and
`ara::phm::HealthChannel` status files, then triggers restart recovery when failures are detected.
`autosar-watchdog.service` supervises the runtime heartbeat.
This is the recommended way to run user-defined applications on Raspberry Pi.

`autosar-user-app-monitor` also supports:
- startup grace (`AUTOSAR_USER_APP_MONITOR_STARTUP_GRACE_MS`)
- restart backoff (`AUTOSAR_USER_APP_MONITOR_RESTART_BACKOFF_MS`)
- deactivated-stop allowance (`AUTOSAR_USER_APP_MONITOR_ALLOW_DEACTIVATED_AS_HEALTHY`)

Runtime files used by registration/monitoring:
- `/run/autosar/user_apps_registry.csv` (generated by `bringup.sh`)
- `/run/autosar/user_app_monitor.status` (generated by user-app monitor daemon)
- `/run/autosar/phm/health/*.status` (generated by `ara::phm::HealthChannel`)

`bringup.sh` helper API:
- `launch_app "<name>" <command> [args...]`
  : Registers PID, default instance specifier, and default restart policy.
- `launch_app_with_heartbeat "<name>" "<heartbeat_file>" "<timeout_ms>" <command> [args...]`
  : Adds heartbeat freshness checks on top of liveness and restart policy.
- `launch_app_managed "<name>" "<instance_specifier>" "<heartbeat_file>" "<timeout_ms>" "<restart_limit>" "<restart_window_ms>" <command> [args...]`
  : Full AUTOSAR-like registration with explicit PHM instance and restart policy.

## 5) Validate readiness and communication paths

```bash
./scripts/verify_rpi_ecu_profile.sh \
  --prefix /opt/autosar_ap \
  --user-app-build-dir /opt/autosar_ap/user_apps_build \
  --can-backend mock \
  --require-platform-binary
```

For real CAN input:

```bash
./scripts/verify_rpi_ecu_profile.sh \
  --prefix /opt/autosar_ap \
  --user-app-build-dir /opt/autosar_ap/user_apps_build \
  --can-backend socketcan \
  --can-if can0 \
  --require-platform-binary
```

## Operational Notes

- This profile targets Linux-based prototype ECU operation.
- It is not a certified commercial AUTOSAR stack.
- Safety/security hardening (ASIL/SOTIF, secure boot chain, full update campaign,
  production diagnostics, watchdog integration policy) remains product work.
